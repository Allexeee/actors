## Что такое ACTORS
ACTORS - это игровой фреймворк реализующий архитектурный шаблон ECS 
(сущность-компонент-система) разработанный специально для движка Unity3d. В задачи фреймворка входит объединение различных фич юнити в единую, предсказуемую, легкорасширяемую среду разработки. 

## Фишки фреймворка:
- Мультисцены : фреймворк основан на идее использования нескольких сцен Unity одновременно. В отличии от префабов сцены дают гораздо больше свободы для работы и композиции. 

- Сигналы: служат для обемена данными/событиями по типу между не связанными частями приложения. 

- Toolbox: контейнер в котором хранятся службы, обработчики, менеджеры. Toolbox глобален и работает на всех сценах.

- Pools: пулы игровых объектов. Элемент оптимизации когда мы вместо уничтожения объекта деактивируем его и в последствии вместо создания нового объекта используем деактивированный. Отлично подходит в случаях большого кол-ва игровых объектов с коротким игровым циклом. Например летящие снаряды.

- Timers: таймеры - это отложенные действия. С помощью таймера можно задать время и передать метод который должен сработать. Таймеры быстрее и удобнее корутин если нужно единоразово выполнить отложенное действие. Таймеры можно так же кешировать, ставить на паузу, убивать и перезапускать с другим временем, методами.

- Система тэгов: Тэги это целочисленные значения которые могут быть отражены по имени в инспекторе. Во многом тэги похожи на enumы. Тэги широко используются в фильтрации сущностей, передачи событий.

- Стартеры: в Unity3d нет "единой" точки входа в игру. Стартеры это компоненты ответственные за корректный запуск сцены, подгрузки других сцен если используются мультисцены, грамотной инициализации начальных сущностей на сцене и добавления всех обработчиков/менеджеров для работы уровня.

- Сущности: сущностями выступают числовые ID. Сущность - это абстракция для связи компонентов данных и поведений в игре. Во фреймворке можно реализовать как абстрактные сущности не привязанные к игровым объектам, так и работать с акторами ( игровыми объектами ) которые так же основаны на сущностях.

- Компоненты Actors: акторы наследуются от monobehavior компонентов и являются сущностями. Наследуясь от актора мы определяем его поведение через передаваемые компоненты данных. Сам по себе актор не содержит игровой логики. Как и во многих ECS фреймворках сущностью выступает числовой ID, однако учитывая специфику Unity3d мы будем много работать с unity объектами поэтому  довольно часто будем обращаться именно к акторам. Сложные многосоставные игровые объекты могут состоять из нескольких вложенных акторов однако в 90% случаев актор - единственный компонент на игровом объекте отвечающий за его содержание и поведение.

- Processings: обработчики - это "менеджеры"/"контроллеры" игры. Они добавляются в Toolbox через Starter ( как правило ) и в большинстве случаев являются системами для обработки логики сущностей/акторов.

- Groups: группы - это фильтры собирающие сущностей/акторов по наличию нужных компонентов или тэгов. Во все зарегистрированные группы автоматически передаются любые изменения сущности.

- Behaviors: поведения - это "система" наоборот: если в классическом ECS системы с фильтрами определяют какие сущности будут у них работать, то поведения работают по ручному подключению и без фильтраций по компонентам данных. Разработчик в ответе за проверки может ли работать поведение или нет. Это отдельная тема : )

- Data: компоненты данных - кирпичики игровой логики. Все игровые переменные хранятся в этих компонентах. Компоненты данных не должны содержать логики.

- Samples: просто переименнованный scriptable object (SO). Я нахожу слово "образец" более логичным и соответствующим. Образцы нужны для определениях неизменяемого шаблона для объекта. Так например образец оружия будет содержать тип снарядов, силу отдачи, размер обоймы и прочие настроечные аспекты. Преимуществом SO ( scriptable object ) является возможность сохранять его как ассет и реализовывать внутри логику по необходимости.

- Factory: Фабрики - это SO для создания игровых сущностей. Они полезны когда нужно скрыть рутину по настройке создания игрового объекта. Например создавая нового игрового героя мы хотим добавить новый интерфейс для него, задать какие-то параметры и породить собачку-спутника. Вместо того чтобы писать все это в коде игры мы просто обращаемся к фабрике прося вернуть нам нового героя, а фабрика уже заботится о всех зависимостях.


## Создаем компонент данных.
По умолчанию я называю компоненты данных начиная с Data.  Например DataMove. Компоненты данных наследуются от интерфейса IData.
```csharp
public DataMove : IData{
  public Vector3 direction;
  public float speed;
}
```
Допустим мы хотим добавить коллайдер который будет передаваться из актора. Для такого используется интерфейс ISetup
```csharp
public DataMove : IData, ISetup{
  public Collider2D collider;
  public Vector3 direction;
  public float speed;

 public void Setup(Actor actor)
    {
        // назначаем коллайдер из актора который принял эту дату.
        // для вытаскивания данных мы используем Get<T>("путь в иерархии объекта") 
        collider = actor.Get<Collider2D>("view/solid");
    }

}
```
Если по какой-то причине нужно вручную почистить  компонент то добавляем интерфейс IDisposable

```csharp
public DataMove : IData, ISetup, IDisposable{
  public Collider2D collider;
  public Vector3 direction;
  public float speed;

 public void Setup(Actor actor)
    {
        // назначаем коллайдер из актора который принял эту дату.
        // для вытаскивания данных мы используем Get<T>("путь в иерархии объекта") 
        collider = actor.Get<Collider2D>("view/solid");
    }

 public void Dispose()
    {
    // убиваем ссылку вручную
    collider = null;
    }

}
```
 
Если мы хотим чтобы компонент даты отображался в инспекторе для визуального редактирования и вообще существовал сразу то добавляем атрибут
[System.Serializable]
```csharp
[System.Serializable]
public DataMove : IData{
  public Vector3 direction;
  public float speed;
}
```
[![Image from Gyazo](https://i.gyazo.com/1d140b60ede5ae1513b22b6b03bde068.gif)](https://gyazo.com/1d140b60ede5ae1513b22b6b03bde068)

*На заметку*
- Методы ISetup и IDisposable опциональны и добавляютя по необходимости. Например ISetup добавляется когда мы хотим без визуального редактирования сделать настройки данных из актора.

- Данные **не** должны содержать никакой игровой логики. Это просто контейнеры с переменными.

- Как правило нет смысла кешировать компоненты с GO ( gameobject ) такие как трансформ - к ним можно легко обращаться из актора. Имеет смысл только если нужна максимальная скорость обращения к компоненту.

- Хорошо планируйте свои компоненты данных - это кирпичи игровой логики. Старайтесь объединять переменные в компоненты данных по логическому принципу, обобщайте. Совершенно нормально что для некоторых из поведений не все переменные будут использоваться. 



